#!/usr/bin/env python2.7

from githg import (
    ChangesetData,
    GitHgStore,
    split_ls_tree,
    one,
)
from git import (
    FastImport,
    Git,
)
from githg.dag import gitdag
import sys
import subprocess

import logging
#logging.getLogger('').setLevel(logging.INFO)


def fsck(args):
    # TODO: Add arguments to enable more sha1 checks
    status = { 'broken': False }

    def report(message):
        status['broken'] = True
        print message

    Git.register_fast_import(FastImport())
    store = GitHgStore()

    all_notes = set(path.replace('/', '') for mode, typ, filesha1, path in
        Git.ls_tree('refs/notes/remote-hg/git2hg', recursive=True))

    manifest_commits = set(Git.iter('rev-list', '--full-history',
                                    'refs/remote-hg/manifest'))

    def all_git_heads():
        for ref in Git.for_each_ref('refs/remote-hg/head-*',
                                    format='%(refname)'):
            yield ref + '\n'

    all_git_commits = Git.iter('log', '--topo-order', '--full-history',
                               '--reverse', '--stdin', '--format=%T %H',
                               stdin=all_git_heads)

    seen_changesets = set()
    seen_manifests = set()
    seen_files = set()
    seen_notes = set()

    for line in all_git_commits:
        tree, node = line.split(' ')
        if node not in all_notes:
            report('Missing note for git commit: ' + node)
            continue
        seen_notes.add(node)

        changeset_data = store.read_changeset_data(node)
        changeset = changeset_data['changeset']
        seen_changesets.add(changeset)
        changeset_ref = store.changeset_ref(changeset)
        if not changeset_ref:
            report('Missing changeset in hg2git branch: %s' % changeset)
        if changeset_ref != node:
            report('Commit mismatch for changeset %s\n'
                   '  hg2git: %s\n  commit: %s'
                   % (changeset, changeset_ref, node))

        hg_changeset = store.changeset(changeset, include_parents=True)
        if hg_changeset.node != hg_changeset.sha1:
            report('Sha1 mismatch for changeset %s' % changeset)

        manifest = changeset_data['manifest']
        if manifest in seen_manifests:
            continue
        seen_manifests.add(manifest)
        manifest_ref = store.manifest_ref(manifest)
        if not manifest_ref:
            report('Missing manifest in hg2git branch: %s' % manifest)
        elif manifest_ref not in manifest_commits:
            report('Missing manifest commit in manifest branch: %s' %
                   manifest_ref)

        git_ls = one(Git.ls_tree(manifest_ref, 'git'))
        if not git_ls:
            report('Missing git tree in manifest commit %s' % manifest_ref)
        else:
            mode, typ, sha1, path = git_ls
            if sha1 != tree:
                report('Tree mismatch between manifest commit %s and commit %s'
                       % (manifest_ref, node))

    # TODO: Check files
    all_hg2git = set(path.replace('/', '') for mode, typ, filesha1, path in
        Git.ls_tree('refs/remote-hg/hg2git', recursive=True) if typ=='commit')

    for obj in all_hg2git - seen_changesets - seen_manifests - seen_files:
        report('Dangling metadata for ' + obj)

    for commit in all_notes - seen_notes:
        report('Dangling note for commit ' + commit)

    return 1 if status['broken'] else 0


def main(args):
    cmd = args.pop(0)
    if cmd == 'data':
        store = GitHgStore()
        if args[0] == '-c':
            sys.stdout.write(store.changeset(args[1]).data)
        elif args[0] == '-m':
            sys.stdout.write(store.manifest(args[1]).data)
    elif cmd == 'restore':
        num = int(args[0])

        for ref in ('tip', 'manifest', 'hg2git'):
            Git.update_ref('refs/remote-hg/%s' % ref,
                'refs/remote-hg/%s@{%d}' % (ref, num))
        Git.update_ref('refs/notes/remote-hg/git2hg',
            'refs/notes/remote-hg/git2hg@{%d}' % num)

        # Ensure all the above has been applied before doing ls-tree below.
        Git.close()

        def rev_list_input():
            for mode, typ, filesha1, path in Git.ls_tree(
                    'refs/notes/remote-hg/git2hg', recursive=True):
                yield path.replace('/', '') + '\n'
            yield '^refs/remote-hg/manifest\n'

        dag = gitdag(Git.iter('rev-list', '--stdin', '--parents',
            '--full-history', stdin=rev_list_input))

        heads = {}
        for head in dag.heads:
            ref = 'refs/remote-hg/head-%s' % ChangesetData.parse(
                Git.read_note('remote-hg/git2hg', head)
                )['changeset']
            heads[ref] = head

        for ref in Git.for_each_ref('refs/remote-hg/head-*',
                format='%(refname)'):
            if ref not in heads:
                Git.delete_ref(ref)

        for head in heads:
            Git.update_ref(head, heads[head])
    elif cmd == 'fsck':
        return fsck(args)

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
