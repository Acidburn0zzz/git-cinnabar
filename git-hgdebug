#!/usr/bin/env python2.7

from githg import (
    ChangesetData,
    GitHgStore,
    split_ls_tree,
    one,
)
from git import (
    FastImport,
    Git,
)
from githg.dag import gitdag
import sys
import subprocess

import logging
#logging.getLogger('').setLevel(logging.INFO)


def fsck(args):
    # TODO: Add arguments to enable more sha1 checks
    status = { 'broken': False }

    def report(message):
        status['broken'] = True
        print message

    Git.register_fast_import(FastImport())
    store = GitHgStore()

    all_notes = set(path.replace('/', '') for mode, typ, filesha1, path in
        Git.ls_tree('refs/notes/remote-hg/git2hg', recursive=True))

    manifest_commits = set(Git.iter('rev-list', '--full-history',
                                    'refs/remote-hg/manifest'))

    def all_git_heads():
        for ref in Git.for_each_ref('refs/remote-hg/head-*',
                                    format='%(refname)'):
            yield ref + '\n'

    all_git_commits = Git.iter('log', '--topo-order', '--full-history',
                               '--reverse', '--stdin', '--format=%T %H',
                               stdin=all_git_heads)

    seen_changesets = set()
    seen_manifests = set()
    seen_files = set()
    seen_notes = set()

    for line in all_git_commits:
        tree, node = line.split(' ')
        if node not in all_notes:
            report('Missing note for git commit: ' + node)
            continue
        seen_notes.add(node)

        changeset_data = store.read_changeset_data(node)
        if 'extra' in changeset_data:
            extra = dict(i.split(':', 1)
                         for i in changeset_data['extra'].split('\0'))
            if 'committer' in extra:
                header, message = Git.cat_file('commit', node).split('\n\n', 1)
                header = dict(l.split(' ', 1) for l in header.splitlines())
                committer = '%s %s %d' % store.hg_author_info(
                    header['committer'])
                if committer != extra['committer']:
                    report('Committer mismatch between commit and metadata for'
                           ' changeset %s' % changeset_data['changeset'])

        changeset = changeset_data['changeset']
        seen_changesets.add(changeset)
        changeset_ref = store.changeset_ref(changeset)
        if not changeset_ref:
            report('Missing changeset in hg2git branch: %s' % changeset)
        if changeset_ref != node:
            report('Commit mismatch for changeset %s\n'
                   '  hg2git: %s\n  commit: %s'
                   % (changeset, changeset_ref, node))

        hg_changeset = store.changeset(changeset, include_parents=True)
        sha1 = hg_changeset.sha1
        if hg_changeset.node != sha1:
            if (changeset, sha1) in (
                ('8c557b7c03a4a753e5c163038f04862e9f65fce1',
                 '249b59139de8e08abeb6c4e261a137c756e7af0e'),
                ('ffdee4a4eb7fc7cae80dfc4cb2fe0c3178773dcf',
                 '415e9d2eac83d508bf58a4df585c5f6b2b0f44ed'),
                ('fca5ddbaa12af32fec357270b3da336c7817054b',
                 'b5f8c47ab63ea4eed195d9f3e5d4b66296f25a6e'),
                ('725e3d3145d82d1a9b23160cec3d58d22f398899',
                 '7f5ec96b83b41872f29b2eb99dfca06c6f8e8b4b'),
                ('a73a785ea8e1624a57c2e9479345b5cd2a953127',
                 '5f09cdb66b0ee6d61708d31ea25e42703bd2339d'),
            ):
                print 'Ignoring known sha1 mismatch for changeset %s' % (
                    changeset)
            else:
                report('Sha1 mismatch for changeset %s' % changeset)

        manifest = changeset_data['manifest']
        if manifest in seen_manifests:
            continue
        seen_manifests.add(manifest)
        manifest_ref = store.manifest_ref(manifest)
        if not manifest_ref:
            report('Missing manifest in hg2git branch: %s' % manifest)
        elif manifest_ref not in manifest_commits:
            report('Missing manifest commit in manifest branch: %s' %
                   manifest_ref)

        git_ls = one(Git.ls_tree(manifest_ref, 'git'))
        if not git_ls:
            report('Missing git tree in manifest commit %s' % manifest_ref)
        else:
            mode, typ, sha1, path = git_ls
            if sha1 != tree:
                report('Tree mismatch between manifest commit %s and commit %s'
                       % (manifest_ref, node))

    # TODO: Check files
    all_hg2git = set(path.replace('/', '') for mode, typ, filesha1, path in
        Git.ls_tree('refs/remote-hg/hg2git', recursive=True) if typ=='commit')

    for obj in all_hg2git - seen_changesets - seen_manifests - seen_files:
        report('Dangling metadata for ' + obj)

    for commit in all_notes - seen_notes:
        report('Dangling note for commit ' + commit)

    if status['broken']:
        print 'Your git-remote-hg repository appears to be corrupted. There'
        print 'are known issues in older revisions that have been fixed.'
        print 'Please try running the following command to reset:'
        print '  git hgdebug reclone'
        print '\nPlease note this command may change the commit sha1s. Your'
        print 'local branches will however stay untouched.'
        print 'Please report any corruption that fsck would detect after a'
        print 'reclone.'

    return 1 if status['broken'] else 0


def main(args):
    cmd = args.pop(0)
    if cmd == 'data':
        store = GitHgStore()
        if args[0] == '-c':
            sys.stdout.write(store.changeset(args[1]).data)
        elif args[0] == '-m':
            sys.stdout.write(store.manifest(args[1]).data)
    elif cmd == 'restore':
        num = int(args[0])

        for ref in ('tip', 'manifest', 'hg2git'):
            Git.update_ref('refs/remote-hg/%s' % ref,
                'refs/remote-hg/%s@{%d}' % (ref, num))
        Git.update_ref('refs/notes/remote-hg/git2hg',
            'refs/notes/remote-hg/git2hg@{%d}' % num)

        # Ensure all the above has been applied before doing ls-tree below.
        Git.close()

        def rev_list_input():
            for mode, typ, filesha1, path in Git.ls_tree(
                    'refs/notes/remote-hg/git2hg', recursive=True):
                yield path.replace('/', '') + '\n'
            yield '^refs/remote-hg/manifest\n'

        dag = gitdag(Git.iter('rev-list', '--stdin', '--parents',
            '--full-history', stdin=rev_list_input))

        heads = {}
        for head in dag.heads:
            ref = 'refs/remote-hg/head-%s' % ChangesetData.parse(
                Git.read_note('remote-hg/git2hg', head)
                )['changeset']
            heads[ref] = head

        for ref in Git.for_each_ref('refs/remote-hg/head-*',
                format='%(refname)'):
            if ref not in heads:
                Git.delete_ref(ref)

        for head in heads:
            Git.update_ref(head, heads[head])
    elif cmd == 'fsck':
        return fsck(args)
    elif cmd == 'reclone':
        for ref in Git.for_each_ref('refs/remote-hg', format='%(refname)'):
            Git.delete_ref(ref)
        Git.delete_ref('refs/notes/remote-hg/git2hg')
        Git.close()

        for line in Git.iter('config', '--get-regexp', 'remote\..*\.url'):
            config, url = line.split()
            name = config[len('remote.'):-len('.url')]
            if url.startswith('hg::'):
                Git.run('remote', 'update', '--prune', name)

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
